# 알고리즘의 효율 분석

## 1. 시간 복잡도란?

시간 복잡도란, 알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미한다. 시간 복잡도는 낮으면 낮을수록 좋다.  

<br/>

### 1차원 배열 검색하기

1차원 배열에서 값을 가장 빨리 찾는 경우 1번만에 찾을 수 있다.  
하지만, 값을 가장 늦게 찾는 경우에는 전체 배열을 탐색해야 할 수도 있다.  

<br/>

### 알고리즘 수행 시간을 측정하는 방법

시간 복잡도를 측정하는 방법은 연산 횟수와 관련이 있다.  
시간 복잡도는 알고리즘이 시작한 순간부터 결과값이 나올 때까지의 연산 횟수를 나타낸다.  

입력 크기에 한하여 연산 횟수를 기준으로 시간 복잡도를 측정하지 않고, 입력 크기를 N으로 일반화하여 연산 횟수의 추이를 나타내야 한다.  
코딩 테스트에서는 모든 경우의 수에서 알고리즘이 문제를 처리하는 것을 고려해야 하므로 시간 복잡도는 최악의 경우를 가정하여 이야기하는 것이 일반적이다.  

<br/>

### 최악의 경우 시간 복잡도를 표현하는 빅오 표기법

빅오 표기법은 어떤 프로그램의 연산 횟수가 f(x)라고 할 때 함수의 최고사항을 남기고 계수를 지워 O(..)와 같이 표기한다.  

예를 들어, 어떤 프로그램의 연산 횟수가 f(x) = 2x^2 + 3x + 5라면 시간 복잡도를 O(X^2) 같이 표현하면 된다.  

```
3x^2 + 5x + 6 -> O(x^2)
x + logx -> O(x)
2^x + 10x^5 + 5x^2 -> O(2^x)
5x^2 - 6x -> O(x^2)
```
<br/>

#### 예시

```java
// n = x 일 때
// f(x) = x^2 + 3x + 5

public static void solution(int n) {
    int count = 0;

    // n^2 연산
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            count++;
        }
    }

    // n 연산
    for (int i = 0; i < n; i++) {
        count++;
    }

    // n * 2 연산
    for (int i = 0; i < n *2; i++) {
        count++;
    }

    // 5 연산
    for (int = 0; i < 5; i++) {
        count++;
    }
}
```
